REFERENCE_OCR (형식 참고용 OCR 예시):
{example_ocr}

REFERENCE_JSON (정답 구조 예시):
{example_answer_str}

TARGET_OCR (실제 처리 대상 OCR 텍스트):
{ocr_text}


MISSION:
1. 너는 TARGET_OCR을 기반으로 문서를 **완전히 재구조화**해야 한다.
2. 출력은 REFERENCE_JSON과 **동일한 JSON 구조와 의미 체계**를 따라야 한다.
3. 문서에 실제로 존재하는 정보만 추출해야 하며,
   임의로 값을 생성·추측·보완해서는 안 된다.
4. **JSON 필드명(키)은 REFERENCE_JSON과 정확히 동일하게 유지**해야 한다.
   - 필드명을 한글로 번역하거나 변경하면 안 된다.
   - 예: "請求伝票番号" (O), "請求伝票번호" (X), "請求伝票番号"를 "청구전표번호"로 변경 (X)
5. 출력 형식은 반드시 **JSON** 이어야 한다.

REFERENCE_JSON 사용 규칙:
- REFERENCE_JSON은 **구조, 필드 구성, 의미 체계 참고용 예시**이다.
- **필드명(키)은 REFERENCE_JSON과 정확히 동일하게 복사**해야 한다.
  - 필드명을 번역하거나 변경하면 절대 안 된다.
  - 예: "請求伝票番号", "得意先CD", "商品名" 등 모든 필드명을 그대로 사용
- 값을 복사하거나, 값의 존재 여부를 추론하는 데 사용해서는 안 된다.
- 모든 값은 반드시 TARGET_OCR에서만 추출해야 한다.

STRUCTURE RULES:
6. **필드명(키) 규칙 (절대 준수)**
   - 모든 JSON 필드명은 REFERENCE_JSON의 필드명과 **정확히 동일**해야 한다.
   - 필드명에 한글을 섞거나 번역하면 안 된다.
   - 일본어 필드명은 그대로 유지: "請求伝票番号", "得意先CD", "商品名" 등
7. page_role은 항상 문자열이며, 반드시 아래 중 하나여야 한다.
   - "cover"
   - "detail"
   - "summary"
   - "reply"

8. detail 페이지에서 items는 **항상 배열([])** 이어야 한다.
   - 항목이 없으면 빈 배열 []을 반환한다.
   - null 반환은 절대 금지한다.

9. cover와 reply 페이지에는 items가 없다. 따라서 빈 배열이 아니라 그냥 키값 생성 자체를 금지한다.

10. page_role 판단 힌트 (최소 규칙):
- cover:
  - 회사명, 주소, 청구서 제목, 문서 식별 정보 중심
  - 상품/조건 반복 행(item)이 없음
- detail:
  - 상품, 조건, 수량, 금액 등의 **반복 행 구조**가 존재
  - items 배열로 표현 가능
- summary:
  - 합계, 세금, 총 청구 금액 등 **요약 금액 정보 중심**
  - 개별 상품 행은 없음
- reply:
  - cover와 유사하나 첫장에 위치해 있지 않음
  - 대응하는 cover 페이지가 있음

EXTRACTION RULES:
11. **중복 제거 절대 금지**
   - OCR에 존재하는 모든 행을 빠짐없이 추출해야 한다.
   - 완전히 동일한 행이 반복되더라도 모두 items 배열에 포함시킨다.
   - OCR 상의 아이템 개수와 items 배열의 길이는 반드시 일치해야 한다.

12. 모든 필드는
    - 문서에 실제로 존재하는 경우에만 값을 채운다.
    - 문서에 없는 필드는 반드시 null로 반환한다.

**備考 / 条件備考 구분 (v4)**
- **備考**와 **条件備考**는 서로 다른 필드다. **둘 다** REFERENCE_JSON에 키가 있으면 반드시 매 행마다 채운다.
- **備考**: 표에 "備考" 헤더가 있는 열 = 키 **備考**. REFERENCE_OCR에서 備考 값이 나오는 **같은 상대 위치**의 셀을 TARGET에서 찾아 備考에 넣는다. (담당자명·이름 등 짧은 텍스트. 예: "栗田　康広".) 값이 있으면 반드시 추출하고, 빈칸이면 null. **줄바꿈(\n)은 공백 하나로 바꿔서** 출력한다. 탭은 쓰지 말고 공백만.
- REFERENCE_JSON에 "条件備考" 키가 있으면, **헤더에 "条件備考"가 없어도** 다음처럼 유추한다:
  1) REFERENCE_OCR에서 REFERENCE_JSON의 条件備考 **값이 나오는 위치**를 본다. (예: 加藤 문서에서는 각 행 **오른쪽 끝**의 긴 텍스트 "ミセダシ　ウリアゲ　キホンジョウケン" 등이 条件備考다.)
  2) TARGET_OCR에서 **같은 상대 위치**를 찾는다. = 각 상품 행에서 **오른쪽 끝**에 있는 긴 한 블록. 문서에 따라 "ＳＣ：７桁コード"·숫자·"Ｎ１　Ｋ" 등이 함께 나오는 내용을 条件備考에 넣는다.
  3) 키는 정확히 条・件・備・考 4자. **출력 시 반드시:** 条件備考 값 안에서 연속된 공백·탭·全角スペース(Ｕ+3000)는 **하나의 보통 공백으로 줄여서** 출력한다. JSON 문자열 안에는 **탭(\t)을 쓰지 말고** 공백만 쓴다. (연속 공백을 그대로 넣으면 응답이 잘려 파싱 오류가 난다.)
- 요약: REFERENCE에서 条件備考 값이 **어느 열/위치**(보통 행 오른쪽 끝)인지 확인한 뒤, TARGET에서 **같은 위치**의 텍스트를 条件備考로 채운다.

IMPORTANT:
13. 이 작업은 "질문에 대한 부분 응답"이 아니라,
    **OCR 문서 전체를 정규화된 JSON으로 재구조화하는 작업**이다.

14. TARGET_OCR은 출력 범위를 제한하기 위한 것이 아니라,
    **page_role을 판단하고 전체 구조를 재구성하기 위한 입력 데이터**이다.

15. **필드명 번역 금지 (최우선 규칙)**
    - JSON 필드명은 REFERENCE_JSON과 정확히 동일해야 한다.
    - "請求伝票番号"를 "請求伝票번호"로 변경하거나 한글을 섞으면 안 된다.
    - "請求伝票番号"를 "청구전표번호"로 번역하면 안 된다.
    - 모든 필드명은 REFERENCE_JSON에서 복사하여 그대로 사용해야 한다.


ANSWER:
